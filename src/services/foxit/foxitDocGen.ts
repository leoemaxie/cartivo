/**
 * Foxit Document Generation API Client
 *
 * Calls the Foxit Document Generation REST API to produce dynamic PDF reports
 * from structured JSON bundle data. Uses a pre-configured template on the Foxit
 * platform that knows how to render Cartivo bundle data into a polished PDF.
 *
 * API Reference: https://api.foxitsoftware.com/document-generation/v1
 */

const FOXIT_DOC_GEN_BASE_URL =
  import.meta.env.VITE_FOXIT_DOC_GEN_URL ||
  'https://api.foxitsoftware.com/document-generation/v1'

const FOXIT_API_KEY = import.meta.env.VITE_FOXIT_API_KEY || ''

// The Foxit template ID for Cartivo bundle reports (pre-configured in Foxit dashboard)
const CARTIVO_TEMPLATE_ID =
  import.meta.env.VITE_FOXIT_TEMPLATE_ID || 'cartivo-smart-bundle-report-v1'

// ============================================================
// Request / Response types
// ============================================================

export interface ProductReportData {
  id: string
  name: string
  brand: string
  category: string
  price: number
  imageUrl: string
  sustainabilityScore: number
  durabilityScore: number
  averageRating: number
  warrantyYears: number
  styleTags: string[]
  description: string
  compatibleWith: string[]
  requiredAccessories: Array<{ name: string; price: number }>
  badge?: 'Best Value' | 'Most Sustainable' | 'Top Rated' | 'Budget Pick'
}

export interface ReplacementReportData {
  originalProductName: string
  originalPrice: number
  alternativeName: string
  alternativePrice: number
  savings: number
  reason: string
}

export interface BundleReportData {
  reportId: string
  generatedAt: string
  // User preferences
  preferences: {
    budget: number
    categories: string[]
    stylePreferences: string[]
    minSustainability: number
  }
  // Bundle summary
  summary: {
    totalCost: number
    remainingBudget: number
    productCount: number
    isCompatible: boolean
    avgSustainabilityScore: number
    avgDurabilityScore: number
    aiExplanation: string
  }
  // Products in the bundle
  products: ProductReportData[]
  // Budget-saving alternatives
  replacements: ReplacementReportData[]
  // Foxit-specific metadata for template rendering
  meta: {
    cartivoUrl: string
    bundleShareUrl: string
    reportTitle: string
    logoUrl: string
  }
}

export interface FoxitDocGenResponse {
  jobId: string
  status: 'completed' | 'processing' | 'failed'
  pdfUrl?: string
  pdfBase64?: string
  pageCount?: number
  fileSizeBytes?: number
  error?: string
}

// ============================================================
// API helpers
// ============================================================

function getAuthHeaders(): HeadersInit {
  return {
    'Content-Type': 'application/json',
    Authorization: `Bearer ${FOXIT_API_KEY}`,
    'x-foxit-client': 'cartivo/1.0',
  }
}

// ============================================================
// Core API call
// ============================================================

/**
 * Generate a PDF report from bundle data using the Foxit Document Generation API.
 *
 * The API merges the provided JSON data into the pre-configured Cartivo template
 * and returns either a PDF URL or base64-encoded PDF binary.
 */
export async function generateBundlePDF(
  bundleData: BundleReportData
): Promise<FoxitDocGenResponse> {
  if (!FOXIT_API_KEY) {
    throw new FoxitDocGenError(
      'FOXIT_API_KEY_MISSING',
      'Foxit API key is not configured. Set VITE_FOXIT_API_KEY in your environment.'
    )
  }

  const payload = {
    templateId: CARTIVO_TEMPLATE_ID,
    outputFormat: 'pdf',
    data: bundleData,
    options: {
      // Layout settings that translate to PDF rendering instructions
      pageSize: 'A4',
      orientation: 'portrait',
      margins: { top: 20, right: 20, bottom: 20, left: 20 },
      embedFonts: true,
      imageQuality: 85,
      // Table of contents generated by the template engine
      generateTOC: true,
      // Bookmarks matching TOC entries
      generateBookmarks: true,
    },
  }

  const response = await fetch(`${FOXIT_DOC_GEN_BASE_URL}/generate`, {
    method: 'POST',
    headers: getAuthHeaders(),
    body: JSON.stringify(payload),
  })

  if (!response.ok) {
    const errorBody = await response.json().catch(() => ({}))
    throw new FoxitDocGenError(
      'API_ERROR',
      `Foxit Document Generation API returned ${response.status}: ${errorBody.message || response.statusText}`
    )
  }

  const result = (await response.json()) as FoxitDocGenResponse

  if (result.status === 'failed') {
    throw new FoxitDocGenError('GENERATION_FAILED', result.error || 'PDF generation failed')
  }

  return result
}

/**
 * Poll job status until completion (for async generation jobs).
 */
export async function pollJobStatus(
  jobId: string,
  maxAttempts = 20,
  intervalMs = 1500
): Promise<FoxitDocGenResponse> {
  for (let i = 0; i < maxAttempts; i++) {
    const response = await fetch(`${FOXIT_DOC_GEN_BASE_URL}/jobs/${jobId}`, {
      headers: getAuthHeaders(),
    })

    if (!response.ok) {
      throw new FoxitDocGenError('POLL_ERROR', `Failed to poll job status: ${response.status}`)
    }

    const result = (await response.json()) as FoxitDocGenResponse

    if (result.status === 'completed') return result
    if (result.status === 'failed') {
      throw new FoxitDocGenError('GENERATION_FAILED', result.error || 'PDF generation failed')
    }

    await new Promise((resolve) => setTimeout(resolve, intervalMs))
  }

  throw new FoxitDocGenError('TIMEOUT', 'PDF generation timed out after maximum attempts')
}

// ============================================================
// Error type
// ============================================================

export class FoxitDocGenError extends Error {
  code: string
  constructor(code: string, message: string) {
    super(message)
    this.code = code
    this.name = 'FoxitDocGenError'
  }
}

export const isFoxitConfigured = (): boolean => Boolean(FOXIT_API_KEY)
